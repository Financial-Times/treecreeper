// // FROM POST
// describe('updating disconnected records', () => {
// it('updates record with properties', async () => {});
// it('updates metadata', async () => {});
// it('updates record with Documents', async () => {});
// it('updates Date property', async () => {});
// it('updates Datetime property', async () => {});
// it('updates Time property', async () => {});
// it('throws 400 if code in body conflicts with code in url', async () => {});
// it('throws 400 if attempting to write property not in schema', async () => {});
// })
// describe('generic error states', () => {
// it('throws if neo4j query fails', async () => {});
// it('throws if s3 query fails', async () => {});
// it('undoes any s3 actions if neo4j query fails', async () => {});
// describe('creating relationships', () => {
// it('creates record related to existing records', async () => {});
// it('throws 400 when creating record related to non-existent records', async () => {});
// it('creates record related to non-existent records when using upsert=true', async () => {});
// describe('restricted types', () => {
// it('throws 400 when creating restricted record', async () => {});
// it('creates restricted record when using correct client-id', async () => {});
// describe('field locking', () => {
// it('creates a record with _lockedFields', async () => {});
// it('creates a record with multiple fields, locking selective ones', async () => {});
// it('creates a record and locks all fields that are written', async () => {});
// it('throws 400 when clientId is not set', async () => {});

// // FROM V2 PATCH
// describe('v2 - node PATCH', () => {});
// it('update node in neo4j with non-document properties only', async () => {});
// it('update node in s3 with document properties only', async () => {});
// it('update node in neo4j and s3 with document and non-document properties', async () => {});
// it('Not create property when passed empty string', async () => {});
// describe('temporal properties', () => {});
// it('Set Date property when no previous value', async () => {});
// it('Overwrite existing Date property', async () => {});
// it('Remove property when empty string sent in payload', async () => {});
// it('Not remove property when falsy value sent in payload', async () => {});
// it('Create when patching non-existent node', async () => {});
// it('Not create when patching non-existent restricted node', async () => {});
// it('Create when patching non-existent restricted node with correct client-id', async () => {});
// it('error when conflicting code values', async () => {});
// it('error when unrecognised attribute', async () => {});
// it('responds with 500 if neo4j query fails', async () => {});
// it('responds with 500 if s3 query fails', async () => {});
// it('no client-id header deletes the _updatedByClient metaProperty from the database', async () => {});
// it('no client-user-id header deletes the _updatedByUser metaProperty from the database', async () => {});
// describe('relationship patching', () => {});
// describe('deleting', () => {});
// it('errors if no relationshipAction query string when deleting relationship set', async () => {});
// it('errors if no relationshipAction query string when deleting individual relationship', async () => {});
// describe('individual relationship delete', () => {});
// it('can delete a specific relationship', async () => {});
// it('can delete multiple specific relationships of the same kind', async () => {});
// it('can delete multiple specific relationships of different kinds', async () => {});
// it('leaves relationships in the opposite direction unaffected', async () => {});
// it('can add and remove relationships of the same type at the same time', async () => {});
// it('errors if deleting and adding the same relationship to the same record', async () => {});
// describe('bulk relationship delete', () => {});
// it('can delete empty relationship set', async () => {});
// it('can delete entire relationship sets', async () => {});
// it('leaves other similar relationships on destination node untouched when deleting', async () => {});
// it('leaves relationships in other direction and of other types untouched when deleting', async () => {});
// describe('creating', () => {});
// it('errors if updating relationships without relationshipAction query string', async () => {});
// describe('__-to-one relationships', () => {});
// it('accept a string', async () => {});
// it('accept an array of length one', async () => {});
// it('error if trying to write multiple relationships', async () => {});
// it('replace existing relationship', async () => {});
// describe('merge', () => {});
// it('can merge with empty relationship set if relationshipAction=merge', async () => {});
// it('can merge with relationships if relationshipAction=merge', async () => {});
// describe('replace', () => {});
// it('can replace an empty relationship set if relationshipAction=replace', async () => {});
// it('can replace relationships if relationshipAction=replace', async () => {});
// it('leaves relationships in other direction and of other types untouched when replacing', async () => {});
// it('replaces relationships in multiple directions', async () => {});
// describe('upsert', () => {});
// it('create node related to non-existent nodes when using upsert=true', async () => {});
// it('not leave creation artifacts on things that already existed when using `upsert=true`', async () => {});
// describe('diffing before writes', () => {});
// it('writes if property but no relationship changes detected', async () => {});
// it('writes if relationship but no property changes detected', async () => {});
// it('detects deleted property as a change', async () => {});
// describe('patching with fewer relationships', () => {});
// it('treats fewer relationships as a delete when replacing relationships', async () => {});
// it('treats fewer relationships as no change when merging relationships', async () => {});

// // field locking
// describe('lockedFields', () => {});
// it('throws an error when trying to write a field that is locked by another clientId', async () => {});
// it('writes a field that is unlocked', async () => {});
// it('writes a field that is locked by the same clientId', async () => {});
// it('throws an error when trying to lock a field that is locked by another clientId', async () => {});
// it('updates node by updating field and locking ALL edited fields', async () => {});
// it('updates node by updating someString and adding it as a locked field', async () => {});
// it('updates node that is locked by this clientId', async () => {});
// it('does NOT update node with locked field when it is has already locked it (no duplicates)', async () => {});
// it('adds another field to locked fields', async () => {});
// it('does NOT lock existing fields when those fields are locked by another clientId', async () => {});
// it('does NOT modify lock fields when just updating locked and unlocked fields', async () => {});
// it('only locks fields that are given in the query but updates all fields', async () => {});
// it('creates a new node with locked fields when no exisitng node exists', async () => {});
// it('does NOT overwrite existing locked fields when lockFields=all is set', async () => {});
// it('can lock fields without having to send any data changes', async () => {});
// it('can lock fields when sending values that make no changes', async () => {});
// describe('no client-id header', () => {});
// it('throws an error when clientId is not set', async () => {});
// describe('unlocking fields', () => {});
// it('unlocks fields when request is given', async () => {});
// it('unlocks fields when request is given by a different clientId that locked it', async () => {});
// it('unlocks `all` fields', async () => {});
// it('unlocks the locked field when value sent make no changes', async () => {});
// it('unlocks a locked field and writes new value in same request', async () => {});
// it('unlocks a locked field and writes new locked value in same request', async () => {});
// describe('no value changes', () => {});
// it('unlocks `all` fields', async () => {});
// it('unlocks the only locked field', async () => {});
