# A source code repository
type Repository {
    id: String!
    # Repository URL
    url: String!
    # Display Name
    name: String
    # Repository hosts internal ID
    vcsID: Int
    # SSH URL to checkout the source
    sshUrl: String!
    # Is the repository private
    isPrivate: Boolean
    # Is the repository archived
    isArchived: Boolean
    # Repository description field
    description: String
    # Most recently indexed CircleCI version used
    mostRecentCircleCIPlatform: CircleCiVersion
    # VCS provider that the repository is hosted by
    storedIn: [System] @relation(name: "STORED_IN", direction: "OUT")
    # System which the repository holds the source code of
    system: System @relation(name: "HAS_REPO", direction: "IN")
}

# Any combination of software and technical infrastructure used by the business, engineering or operations.
type System {
    id: String!
    # Display name of the system
    name: String
    # Whether the system is supported
    supported: YesNo
    # The primary URL of the system
    primaryURL: String
    # The system type
    systemType: String
    # The systems service tier level
    serviceTier: ServiceTier
    # The type of service the system provides
    serviceType: String
    # The platform the service is hosted on, e.g. Heroku
    hostPlatform: String
    # Whether the system contains personal PI2 data
    personalData: YesNo
    # Whether the system contains sensitive data
    sensitiveData: YesNo
    # The lifecycle stage of the system
    lifecycleStage: LifeCycleStage
    # If the system is a VCS, the repositories it stores
    stores: [Repository] @relation(name: "STORED_IN", direction: "IN")
    # The other systems the system depends on
    dependsOn(
		# The number of records to return after the pagination offset. This uses the default neo4j ordering
		first: Int = 10,
		# The pagination offset to use
		offset: Int = 0
): [System]
        @relation(name: "DEPENDS_ON", direction: "OUT")
    # The other systems which depend on this system
    isDependencyOf(
		# The number of records to return after the pagination offset. This uses the default neo4j ordering
		first: Int = 10,
		# The pagination offset to use
		offset: Int = 0
): [System]
        @relation(name: "DEPENDS_ON", direction: "IN")
    # The team which supports the system
    supportedBy: Team @relation(name: "SUPPORTS", direction: "IN")
    # Individuals who have operational knowledge of the system
    isKnownBy(
		# The number of records to return after the pagination offset. This uses the default neo4j ordering
		first: Int = 10,
		# The pagination offset to use
		offset: Int = 0
): [Person]
        @relation(name: "KNOWS", direction: "IN")
    # The repository which stores the systems source code
    repository: Repository @relation(name: "HAS_REPO", direction: "OUT")
    # Healthchekcs which are used to monitor this system
    monitoredBy: [Healthcheck] @relation(name: "MONITORED_BY", direction: "IN")
}

# A team within the organisation
type Team {
    id: String!
    # The teams phone contact number
    phone: String!
    # The teams slack contact address
    slack: String!
    # The teams name
    name: String
    # The teams email address
    email: String!
    status: Status!
    # The systems the team supports
    supports(
		# The number of records to return after the pagination offset. This uses the default neo4j ordering
		first: Int = 10,
		# The pagination offset to use
		offset: Int = 0
): [System]
        @relation(name: "SUPPORTS", direction: "IN")
    # The tech leads of systems supported by the team
    techLead(
		# The number of records to return after the pagination offset. This uses the default neo4j ordering
		first: Int = 10,
		# The pagination offset to use
		offset: Int = 0
): [Person]
        @cypher(
            statement: "MATCH (this)-[:HAS {role:'TECH LEAD'}]->(person:Person) RETURN person"
        )
    # The product owners of systems supported by the team
    productOwner(
		# The number of records to return after the pagination offset. This uses the default neo4j ordering
		first: Int = 10,
		# The pagination offset to use
		offset: Int = 0
): [Person]
        @cypher(
            statement: "MATCH (this)-[:HAS {role:'PRODUCT OWNER'}]->(person:Person) RETURN person"
        )
    # The group the team belongs to
    group: Group @relation(name: "HAS_TEAM", direction: "IN")
}

# An overarching group which contains teams and is costed separately
type Group {
    id: String!
    # The name of the group
    name: String
	#
    status: Status
    # The Cost Centre associated with the group
    hasBudget: CostCentre @relation(name: "HAS_BUDGET", direction: "OUT")
    # The teams working under the group
    teams(
		# The number of records to return after the pagination offset. This uses the default neo4j ordering
		first: Int = 10,
		# The pagination offset to use
		offset: Int = 0
): [Team]
        @relation(name: "HAS_TEAM", direction: "OUT")
    # The tech director who owns the group
    techDirector: Person @relation(name: "HAS_TECH_DIRECTOR", direction: "OUT")
}

# A cost centre which groups are costed to
type CostCentre {
    id: String!
    # The name of the cost centre
    name: String
    # The groups which are costed to the cost centre
    hasGroups(
		# The number of records to return after the pagination offset. This uses the default neo4j ordering
		first: Int = 10,
		# The pagination offset to use
		offset: Int = 0
): [Group]
        @relation(name: "HAS_BUDGET", direction: "IN")
}

# A individual within the organisation who is contactable
type Person {
    id: String!
	# The name of the person
    name: String
	# The email address of th person
    email: String
	# The slack link for the person
    slack: String
	# Groups the person is a technical director for
    isTechDirectorFor(first: Int = 10, offset: Int = 0
): [Group]
        @relation(name: "HAS_TECH_DIRECTOR", direction: "IN")
	# Systems the person is a technical lead for
    isTechLeadFor(
		# The number of records to return after the pagination offset. This uses the default neo4j ordering
		first: Int = 10,
		# The pagination offset to use
		offset: Int = 0
): [System]
        @cypher(
            statement: "MATCH (this)-[:HAS {role:'TECH LEAD'}]->(system:System) RETURN system"
        )
	# Systems the person is a product owner for
    isProductOwnerFor(
		# The number of records to return after the pagination offset. This uses the default neo4j ordering
		first: Int = 10,
		# The pagination offset to use
		offset: Int = 0
): [System]
        @cypher(
            statement: "MATCH (this)-[:HAS {role:'PRODUCT OWNER'}]->(system:System) RETURN system"
        )
	# Systems the person has knowledge of
    knows(
		# The number of records to return after the pagination offset. This uses the default neo4j ordering
		first: Int = 10,
		# The pagination offset to use
		offset: Int = 0
): [System]
        @relation(name: "KNOWS", direction: "OUT")
}

type Product {
    id: String!
    purpose: String
    name: String
    serviceTier: ServiceTier!
    primaryURL: String
    status: Status
}

# The configuraiton used to provide monitoring/healthchecks for a system.
type Healthcheck {
    id: String!
    # Whether the monitored entity is live
    isLive: Boolean
    # The URL to check against
    url: String!
    # The systems which the healthcheck monitors
    monitors: [System] @relation(name: "MONITORED_BY", direction: "OUT")
}

enum Status {
    ACTIVE
}

enum YesNo {
    YES
    NO
    UNKNOWN
}

enum LifeCycleStage {
    PRODUCTION
    REQUIREMENTS
    RETIRED
    TESTING
    ANALYSIS
}

# The support level
enum ServiceTier {
    BRONZE
    SILVER
    GOLD
    PLATINUM
}

# The Circle CI version which is running
enum CircleCiVersion {
    ONE
    TWO
    NONE
}

type Query {
    System(
		# The ID of the system to view
		id: String
	): System

    Systems(
		# The service tier of the systems
		serviceTier: ServiceTier,
		# The number of records to return after the pagination offset. This uses the default neo4j ordering
		first: Int = 10,
		# The pagination offset to use
		offset: Int = 0
	): [System]

    Team(
		# The ID of the team to view
		id: String!
	): Team

    Teams(
		# The number of records to return after the pagination offset. This uses the default neo4j ordering
		first: Int = 10,
		# The pagination offset to use
		offset: Int = 0
	): [Team]

    Group(
		# The ID of the group to view
		id: String!
	): Group

    Groups(
		# The number of records to return after the pagination offset. This uses the default neo4j ordering
		first: Int = 10,
		# The pagination offset to use
		offset: Int = 0
	): [Group]

	Healthcheck(
		# The ID of the healthcheck to view
		id: String,
		# The exact URL of the healthcheck to view
		url: String): Healthcheck

    Healthchecks(
		# The number of records to return after the pagination offset. This uses the default neo4j ordering
		first: Int = 10,
		# The pagination offset to use
		offset: Int = 0
	): [Healthcheck]

    Person(
		# The full name of the person to view
		name: String,
		# The ID of the person to view
		id: String
	): Person

    People(
		# The number of records to return after the pagination offset. This uses the default neo4j ordering
		first: Int = 10,
		# The pagination offset to use
		offset: Int = 0
	): [Person]
    Repository(
		# The ID of the repository to view. This is the internal ID, not the VCS provider's ID
		id: String!
	): Repository

    Repositories(
		# The number of records to return after the pagination offset. This uses the default neo4j ordering
		first: Int = 10,
		# The pagination offset to use
		offset: Int = 0
		# The Circle CI version used by the repositories
        mostRecentCircleCIPlatform: CircleCiVersion
    ): [Repository]

    CostCentre(
		# The ID of the cost centre to view
		id: String!
	): CostCentre
}

input SystemInput {
    serviceTier: ServiceTier
    name: String
    supported: YesNo
    primaryURL: String
    systemType: String
    serviceTier: ServiceTier
    serviceType: String
    hostPlatform: String
    personalData: YesNo
    sensitiveData: YesNo
    lifecycleStage: LifeCycleStage
}

type Mutation {
    System(id: String, params: SystemInput): System!
}
